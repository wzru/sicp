<?xml version="1.0" encoding="utf-8"?>
<MATTER>
    <NAME>
        Prefaces
    </NAME>

    <SUBHEADING>
    <NAME>Preface to the JavaScript Adaptation</NAME>
    </SUBHEADING>
    
    <TEXT>
You are reading the book Structure and Interpretation of Computer
Programs (SICP), second edition, JavaScript adaptation. Like the original
version, this book aims firstly to establish the notion that
programming is a medium for communicating ideas about
methodology. Programs allow their authors to describe complex
processes to their readers, provided that both share mental models
that underly the language in which the programs are written. Secondly
it aims to describe programming as an activity to manage the
complexity of software systems, by using abstraction techniques
available in existing programming languages, and by
inventing new languages whenever the need arises.
    </TEXT>
    <TEXT>
To succeed in these goals, the original version focuses on a minimal
set of idioms of the chosen programming language, Scheme. That
set of idioms is not formally taught but assimilated by students
as they make progress digesting the underlying mental models and
abstractions. The book does not aim to teach the language Scheme, but
rather the ability to express procedural ideas in Scheme is
a side effect of achieving its main goals.
    </TEXT>
    <TEXT>
Instead of Scheme, this book (SICP JS), uses JavaScript as its
programming
language. Just like the original, which it closely follows, the
JavaScript adaptation focuses on a minimal set of idioms of the chosen
language.  A reader would be ill-advised to use this book in
order to learn JavaScript. As a drastic example, the notion of a
JavaScript object<EMDASH/>considered one of its fundamental
ingredients by any measure<EMDASH/>is not even mentioned!  The
JavaScript subset used in SICP JS is designed to be just big
enough to express the ideas presented in SICP with a conciseness and
precision that matches the original. (The resulting sublanguage is
described in detail in the web pages that accompany SICP JS.) Just
like the subset of Scheme used in SICP, the subset of JavaScript used
in SICP JS does not need to be formally taught; its mastery is a
side effect of achieving the goals of SICP.
    </TEXT>
    <TEXT>
We sincerely hope that readers for whom this book is their first
encounter with programming will use their newly gained
understanding of the structure and interpretation of computer
programs to study more programming languages, including Scheme
and the full JavaScript language. Readers who have learned
JavaScript prior to picking up SICP JS might gain new
insights into the fundamental concepts that underly the language
and discover how much can be achieved with so little.
Readers who come to SICP JS with a knowledge of the original SICP
might enjoy seeing familiar ideas presented in a new
format<EMDASH/>and might appreciate our comparison version, also
available in the web pages.
    </TEXT>
    <!-- <TEXT> -->
    <!-- You are reading the book -->
    <!-- <EM>Structure and Interpretation of Computer Programs</EM> -->
    <!-- by Harold Abelson and Gerald Jay Sussman<EMDASH/>with a twist. -->
    <!-- The book emphasizes the importance of abstraction for managing -->
    <!-- complexity, and introduces the reader to a host of concepts that -->
    <!-- lie at the heart of the field of computer science. -->
    <!-- Most of these ideas are independent of the language  -->
    <!-- in which programs are written, which employ the ideas for -->
    <!-- solving computational problems. The twist then -->
    <!-- consists of replacing the programming language that is used throughout -->
    <!-- the text, to illustrate the ideas with actual computer programs. -->
    <!-- While the authors used the programming language Scheme, -->
    <!-- this adaptation uses the language JavaScript.  -->
    <!-- </TEXT> -->

    <!-- <TEXT> -->
    <!--   More precisely, this adaptation uses four tiny, carefully designed, -->
    <!--   sublanguages of JavaScript.  -->
    <!--   The languages are called <EM>Source<SPACE/><SECT/>1</EM>, -->
    <!--   <EM>Source<SPACE/><SECT/>2</EM>, <EM>Source<SPACE/><SECT/>3</EM> and <EM>Source<SPACE/><SECT/>4</EM>, -->
    <!--   corresponding to the respective chapters 1, 2, 3 and 4 of the book.  -->
    <!--   The Source<SPACE/><SECT/>1 language contains only constructs that are needed -->
    <!--   in the programs contained in chapter 1: constructs required to  -->
    <!--   <EM>build abstractions with functions</EM>. -->
    <!--   Source<SPACE/><SECT/>2 is a superset of Source<SPACE/><SECT/>1, -->
    <!--   adding features required to build abstractions with data, on top -->
    <!--   of the features of Source<SPACE/><SECT/>1. Similarly,  -->
    <!--   Source<SPACE/><SECT/>3 and 4 extend the previous language -->
    <!--   features required to address the subject of the respective book chapter. -->
    <!--   (Chapter 5 does not require any features beyond Source<SPACE/><SECT/>4.) -->
    <!--   All these languages are sublanguages of JavaScript; any Source program -->
    <!--   is also a JavaScript program, but the reverse is not true. The JavaScript -->
    <!--   language has many features that are not covered in this book. Indeed, -->
    <!--   the Source languages are so small that they can be quite adequately described in -->
    <!--   a few pages of text. The online folder -->
    <!--   <LINK address="https://sicp.comp.nus.edu.sg/source">source</LINK> -->
    <!--   contains the specifications of the Source languages, as reference for -->
    <!--   the reader. -->
    <!-- </TEXT> -->
    <!-- <TEXT>  -->
    <!--   This book is interactive. Most programs are links. Clicking on them -->
    <!--   takes the reader to a web-based programming environment called the -->
    <!--   <LINK address="https://sourceacademy.nus.edu.sg"><EM>Source -->
    <!--   Academy</EM></LINK>. In the Source Academy, the reader can run the programs, -->
    <!--   modify them and -->
    <!--   experiment with them, without the need to install any software, -->
    <!--   and without any requirements on the computer that they use, as -->
    <!--   long as it comes with an internet browser. -->
    <!-- </TEXT> -->
    <!-- <TEXT> -->
    <!--   It is difficult to use a complex programming language such as JavaScript in a -->
    <!--   course for first-year college or university students, even if one imposes -->
    <!--   constraints on the language features to be covered. Students with prior -->
    <!--   knowledge of the language are bound to make use of other features -->
    <!--   in their programs. Their fellow students will legitimately ask the instructors -->
    <!--   about those features, and any answer will either frustrate the -->
    <!--   student or lead to a tangent that is most likely not conducive to the -->
    <!--   learning objectives at hand. This problem is especially severe for JavaScript, -->
    <!--   which is not known for its systematic design. Our solution to this challenge -->
    <!--   is radical: The Source Academy <EM>enforces</EM> the use of the respective -->
    <!--   Source language when the student clicks on a program of a particular chapter. -->
    <!--   Programs that use constructs beyond that language are rejected by the -->
    <!--   Source Academy. This allows instructors of a SICP-based course -->
    <!--   to adopt JavaScript<EMDASH/>one of the most widely used programming languages -->
    <!--   today<EMDASH/>without getting bogged down in JavaScript's plethora of -->
    <!--   idiosyncratic features. -->
    <!-- </TEXT> -->
    <!-- <TEXT> -->
    <!--   The original book was introduced to the National University of Singapore -->
    <!--   by Jacob Katzenelson in 1997, as a more advanced alternative to the regular -->
    <!--   <QUOTE>Programming Methodology</QUOTE> course offered to computer science -->
    <!--   students. The course, known as <QUOTE>CS1101S</QUOTE> since 1998, -->
    <!--   switched to JavaScript in 2012, and became the required freshmen programming -->
    <!--   methodology course for Computer Science undergraduate majors in 2018. -->
    <!-- </TEXT> -->

    <EPIGRAPH>
      <ATTRIBUTION>
        <AUTHOR>Martin Henz and Tobias Wrigstad</AUTHOR> 
      </ATTRIBUTION>
    </EPIGRAPH>

    <SUBHEADING>
      <NAME>Preface to the Second Edition of SICP, 1996</NAME>
    </SUBHEADING>
    
    <EPIGRAPH>
Is it possible that software is not like anything else, that it
is meant to be discarded: that the whole point is to 
always see it as a soap bubble?

      <ATTRIBUTION>
        <AUTHOR>Alan J. Perlis</AUTHOR> 
      </ATTRIBUTION>
    </EPIGRAPH>
<TEXT>    
The material in this book has been the basis of MIT's entry-level
computer science subject since 1980.  We had been teaching this
material for four years when the first edition was published, and
twelve more years have elapsed until the appearance of this second
edition.  We are pleased that our work has been widely adopted and
incorporated into other texts.  We have seen our students take the
ideas and programs in this book and build them in as the core of new
computer systems and languages.  In literal realization of an ancient
Talmudic pun, our students have become our builders.  We are lucky to
have such capable students and such accomplished builders.
</TEXT>
<TEXT>
In preparing this edition, we have incorporated hundreds of 
clarifications suggested by our own teaching experience and the
comments of colleagues at MIT and elsewhere.  We have redesigned
most of the major programming systems in the book, including
the generic-arithmetic system, the interpreters, the register-machine
simulator, and the compiler; and we have rewritten all the program
examples to ensure that any Scheme implementation conforming to
the IEEE Scheme standard (IEEE 1990) will be able to run the code.
</TEXT>
<TEXT>
This edition emphasizes several new themes.  The most important
of these is the central role played by different approaches to
dealing with time in computational models: objects with state,
concurrent programming, functional programming, lazy evaluation,
and nondeterministic programming.  We have included new sections on 
concurrency and nondeterminism, and we have tried to integrate this
theme throughout the book.
</TEXT>
<TEXT>
The first edition of the book closely followed the syllabus of our MIT
one-semester subject.  With all the new material in the second
edition, it will not be possible to cover everything in a single
semester, so the instructor will have to pick and choose.  In our own
teaching, we sometimes skip the section on logic programming
(section<SPACE/><REF NAME="sec:logic-programming"/>),
we have students use the
register-machine simulator but we do not cover its implementation 
(section<SPACE/><REF NAME="sec:simulator"/>),
and we give only a cursory overview of
the compiler
(section<SPACE/><REF NAME="sec:compilation"/>).
Even so, this is still
an intense course.  Some instructors may wish to cover only the first
three or four chapters, leaving the other material for subsequent
courses.
</TEXT>
<TEXT>
The World Wide Web site <LINK address="http://www-mitpress.mit.edu/sicp">of MIT Press</LINK>
provides support for users of this book.
This includes programs from the book,
sample programming assignments, supplementary materials,
and downloadable implementations of the Scheme dialect of Lisp.
</TEXT>

    <EPIGRAPH>
      <ATTRIBUTION>
        <AUTHOR>Harold Abelson and Gerald Jay Sussman</AUTHOR> 
      </ATTRIBUTION>
    </EPIGRAPH>

  <SUBHEADING>  
    <NAME>Preface to the First Edition of SICP, 1984</NAME>
  </SUBHEADING>

    <EPIGRAPH>
A computer is like a violin.  You can imagine a novice trying first a
phonograph and then a violin.  The latter, he says, sounds terrible.
That is the argument we have heard from our humanists and most of our
computer scientists.  Computer programs are good, they say, for
particular purposes, but they aren't flexible.  Neither is a violin,
or a typewriter, until you learn how to use it.
      <ATTRIBUTION>
        <AUTHOR>Marvin Minsky</AUTHOR> 
        <TITLE><QUOTE>Why Programming Is a Good
Medium for Expressing Poorly-Understood and Sloppily-Formulated
Ideas</QUOTE></TITLE>
      </ATTRIBUTION>
    </EPIGRAPH>

    <TEXT>    
<QUOTE>The Structure and Interpretation of Computer Programs</QUOTE> is the
entry-level subject in computer science at the Massachusetts Institute
of Technology.  It is required of all students at MIT who major
in electrical engineering or in computer science, as one-fourth of the
<QUOTE>common core curriculum,</QUOTE> which also includes two subjects on
circuits and linear systems and a subject on the design of digital
systems.  We have been involved in the development of this subject
since 1978, and we have taught this material in its present form since
the fall of 1980 to between 600 and 700 students each year.  Most of
these students have had little or no prior formal training in
computation, although many have played with computers a bit and a few
have had extensive programming or hardware-design experience.
    </TEXT>
    <TEXT>
Our design of this introductory computer-science subject reflects two
major concerns.  First, we want to establish the idea that a computer
language is not just a way of getting a computer to perform operations
but rather that it is a novel formal medium for expressing ideas about
methodology.  Thus, programs must be written for people to read, and
only incidentally for machines to execute.  Second, we believe that
the essential material to be addressed by a subject at this level is
not the syntax of particular programming-language constructs, nor
clever algorithms for computing particular functions efficiently, nor
even the mathematical analysis of algorithms and the foundations of
computing, but rather the techniques used to control the intellectual
complexity of large software systems.
    </TEXT>
    <TEXT>
Our goal is that students who complete this subject should have a good
feel for the elements of style and the aesthetics of programming.
They should have command of the major techniques for controlling
complexity in a large system. They should be capable of reading a
50-page-long program, if it is written in an exemplary style. They
should know what not to read, and what they need not understand at any
moment.  They should feel secure about modifying a program, retaining
the spirit and style of the original author.
    </TEXT>
    <TEXT>
These skills are by no means unique to computer programming.  The
techniques we teach and draw upon are common to all of engineering
design.  We control complexity by building abstractions that hide
details when appropriate.  We control complexity by establishing
conventional interfaces that enable us to construct systems by
combining standard, well-understood pieces in a <QUOTE>mix and match</QUOTE> way.
We control complexity by establishing new languages for describing a
design, each of which emphasizes particular aspects of the design and
deemphasizes others.
    </TEXT>
    <TEXT>
Underlying our approach to this subject is our conviction that
<QUOTE>computer science</QUOTE> is not a science and that its significance has
little to do with computers.  The computer revolution is a revolution
in the way we think and in the way we express what we think.  The
essence of this change is the emergence of what might best be called
<EM>procedural epistemology</EM><EMDASH/>the study of the structure of
knowledge from an imperative point of view, as opposed to the more
declarative point of view taken by classical mathematical subjects.
Mathematics provides a framework for dealing precisely with notions of
<QUOTE>what is.</QUOTE>  Computation provides a framework for dealing precisely
with notions of <QUOTE>how to.</QUOTE>
    </TEXT>
    <TEXT>
In teaching our material we use a dialect of the programming language
Lisp.  We never formally teach the language, because we don't have to.
We just use it, and students pick it up in a few days.  This is one
great advantage of Lisp-like languages: They have very few ways of
forming compound expressions, and almost no syntactic structure.  All
of the formal properties can be covered in an hour, like the rules of
chess.  After a short time we forget about syntactic details of the
language (because there are none) and get on with the real
issues<EMDASH/>figuring out what we want to compute, how we will decompose
problems into manageable parts, and how we will work on the parts.
Another advantage of Lisp is that it supports (but does not enforce)
more of the large-scale strategies for modular decomposition of
programs than any other language we know.  We can make procedural and
data abstractions, we can use higher-order functions to capture common
patterns of usage, we can model local state using assignment and data
mutation, we can link parts of a program with streams and delayed
evaluation, and we can easily implement embedded languages.  All of
this is embedded in an interactive environment with excellent support
for incremental program design, construction, testing, and debugging.
We thank all the generations of Lisp wizards, starting with John
McCarthy, who have fashioned a fine tool of unprecedented power and
elegance.
    </TEXT>
    <TEXT>
Scheme, the dialect of Lisp that we use, is an attempt to bring
together the power and elegance of Lisp and Algol.  From Lisp we take
the metalinguistic power that derives from the simple syntax, the
uniform representation of programs as data objects, and the
garbage-collected heap-allocated data.  From Algol we take lexical
scoping and block structure, which are gifts from the pioneers of
programming-language design who were on the Algol committee.  We wish
to cite John Reynolds and Peter Landin for their insights into the
relationship of Church's lambda calculus to the structure of
programming languages.  We also recognize our debt to the
mathematicians who scouted out this territory decades before computers
appeared on the scene.  These pioneers include Alonzo Church, Barkley
Rosser, Stephen Kleene, and Haskell Curry.
</TEXT>

    <EPIGRAPH>
      <ATTRIBUTION>
        <AUTHOR>Harold Abelson and Gerald Jay Sussman</AUTHOR> 
      </ATTRIBUTION>
    </EPIGRAPH>
  </MATTER>
